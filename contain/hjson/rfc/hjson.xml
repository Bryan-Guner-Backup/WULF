<?xml version="1.0" encoding="utf-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.0.30 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC4627 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4627.xml">
<!ENTITY RFC7159 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7159.xml">
<!ENTITY RFC2119 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC5234 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5234.xml">
<!ENTITY SELF "[RFCXXXX]">
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>

<rfc ipr="pre5378Trust200902" docName="hjson-draft" category="std">

  <front>
    <title abbrev="Hjson">The Human JSON (Hjson) Configuration Format</title>

    <author initials="C." surname="Zangl" fullname="Christian Zangl">
      <organization></organization>
      <address>
        <email>laktak@cdak.net</email>
      </address>
    </author>

    <date year="2016" month="May"/>

    <area>Applications</area>
    <workgroup>none</workgroup>
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>Human JSON (Hjson) is a configuration file format based on the JavaScript Object Notation <xref target="RFC7159"/>. Its focus is to provide a reasonable alternative to plain JSON configs that are hard to edit and do not allow comments.</t>



    </abstract>


  </front>

  <middle>


<section anchor="intro" title="Introduction">

<t>Human JSON (Hjson) is a configuration file format. It is a superset of the JavaScript Object Notation <xref target="RFC7159"/>.</t>

<t>Hjson uses the same four primitive types (strings, numbers, booleans, and null) and two structured types (objects and arrays) as JSON.</t>

<t>A string is a sequence of zero or more Unicode characters <xref target="UNICODE"/>.
Note that this citation references the latest version of Unicode
rather than a specific release. It is not expected that future
changes in the UNICODE specification will impact the syntax of Hjson.</t>

<t>An object is an unordered collection of zero or more name/value
pairs, where a name is a string and a value is a string, number,
boolean, null, object, or array.</t>

<t>An array is an ordered sequence of zero or more values.</t>

<t>The terms “object” and “array” come from the conventions of
JavaScript.</t>

<t>Hjson’s design goals were</t>

<t><list style="symbols">
  <t>to improve readability and editability over JSON while keeping the familiar syntax intact</t>
  <t>to maintain backward compatibility, so that any valid JSON is valid Hjson</t>
  <t>to provide a reasonable alternative to plain JSON configs</t>
</list></t>

<t>Hjson SHOULD be used for data whose primary purpose is to be viewed or edited by a human. For example configuration, resource files or debug data dumps.</t>

<t>Hjson SHOULD NOT be used in other cases, like transfer protocols.</t>

<section anchor="syntax-compared-to-json" title="Syntax compared to JSON">

<t>Hjson is a superset of JSON. Its syntax allows you to</t>

<t><list style="symbols">
  <t>add #, // or /**/ comments,</t>
  <t>omit quotes for keys,</t>
  <t>omit quotes for strings (terminated by LF, no escapes),</t>
  <t>omit braces for the root object,</t>
  <t>omit the comma at the end of a line</t>
  <t>add trailing commas and</t>
  <t>use multiline strings with proper whitespace handling.</t>
</list></t>

<t>Because the punctuator characters <spanx style="verb">{}[],:</spanx> are used to define the structure of the Hjson text, you need to use quotes</t>

<t><list style="symbols">
  <t>if your key includes a punctuator or space</t>
  <t>if your string starts with a punctuator</t>
</list></t>

<t>For examples see <xref target="json-vs-hjson"/>.</t>

</section>
<section anchor="conventions-used-in-this-document" title="Conventions Used in This Document">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”,
“SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this
document are to be interpreted as described in <xref target="RFC2119"/>.</t>

<t>The grammatical rules in this document are to be interpreted as described in <xref target="RFC5234"/> except where they are specifically marked as <xref target="SABNF"/>.</t>

<t>SABNF is used to express grammars that are not possible in ABNF, like the block-comment, and to define terminators, like ql-end, that allow us to exclude certain sequences. These constructs allow us to generate parsers and to verify the grammar against test cases. For the general understanding of the language they can be ignored.</t>

</section>
<section anchor="specifications-of-hjson" title="Specifications of Hjson">

<t>This document describes Hjson and registers the media type “application/hjson”.</t>

</section>
</section>
<section anchor="hjson-grammar" title="Hjson Grammar">

<t>A Hjson text is a sequence of tokens. The set of tokens includes seven structural characters, comments, strings, numbers, and three literal names.</t>

<t>A Hjson text is either a serialized value or a root object.</t>

<figure><artwork type="abnf"><![CDATA[
   Hjson-text = ws-c ( root-object / value ) ws-c
]]></artwork></figure>

<t>These are the seven structural characters:</t>

<figure><artwork type="abnf"><![CDATA[
   begin-array      = %x5B     ; [ left square bracket

   begin-object     = %x7B     ; { left curly bracket

   end-array        = %x5D     ; ] right square bracket

   end-object       = %x7D     ; } right curly bracket

   name-separator   = %x3A     ; : colon

   comma-separator  = %x2C     ; , comma

   lf-separator     = lf       ; Line feed or New line
]]></artwork></figure>

<t>Insignificant whitespace and comments are allowed before or after any of the first six structural characters.</t>

<figure><artwork type="abnf"><![CDATA[
   ws-c  = *( comment / ws )

   ws    = *( space / tab / lf / cr )

   space = %x20    ; Space
   tab   = %x09    ; Horizontal tab
   lf    = %x0A    ; Line feed or New line
   cr    = %x0D    ; Carriage return
]]></artwork></figure>

<t>Comments can be specified as line or block comments.</t>

<figure><artwork type="abnf"><![CDATA[
   comment = line-comment / block-comment

   line-comment  = ( %x23 /        ; # hash
                     %x2F.2F )     ; // slash + slash
                   *( tab / cr / %x20-10FFFF ) ; until lf

   block-comment = start-block-comment
                   *( !end-block-comment anychar )
                   end-block-comment

   start-block-comment = %x2F.2A   ; /* slash + star

   end-block-comment = %x2A.2F     ; */ star + slash

   anychar = tab / cr / lf / %x20-10FFFF

   ; SABNF: block-comment requies the use of the
   ;        ! operator to allow * and / in the text
   ;        while stopping at */
]]></artwork></figure>

</section>
<section anchor="values" title="Values">

<t>A Hjson value MUST be an object, array, number, or string, or one of
the following three literal names:</t>

<figure><artwork type="abnf"><![CDATA[
   false = %x66.61.6C.73.65   ; false

   null  = %x6E.75.6C.6C      ; null

   true  = %x74.72.75.65      ; true
]]></artwork></figure>

<t>The literal names MUST be lowercase. No other literal names are allowed.</t>

<figure><artwork type="abnf"><![CDATA[
   value = literal / object / array / number / string

   literal = ( false / null / true ) !literal-end

   literal-end =
            *( space / tab )
            ( %x21-22 / %x24-2B / %x2D-2E / %x30-5A /
              %x5C / %x5E-7A / %x7C / %x7E-10FFFF )
            ; exclude #/,[]{}

   ; SABNF: define literal-end to prevent matches
   ;        that are actually a ql-string
   ;        (like "true blue")
]]></artwork></figure>

</section>
<section anchor="value-separators" title="Value Separators">

<t>Values can be separated directly by a comma or indirectly by one or more linefeeds.</t>

<figure><artwork type="abnf"><![CDATA[
   value-separator =  ( ws-c comma-separator ws-c ) /
                      ( *( comment /
                           *(space / tab / cr) )
                        lf-separator ws-c )
]]></artwork></figure>

<t>Note that while Hjson allows the use of lf as a separator, the cr character is generally ignored. This should not be an issue as all modern operating systems use either lf or cr+lf as their line terminator.</t>

</section>
<section anchor="objects" title="Objects">

<t>An object structure is represented as a pair of curly brackets surrounding zero or more name/value pairs (or members). A single colon comes after each name, separating the name from the value. A comma separates a value from the next name unless the value is followed by a linefeed, in which case the comma is optional. Trailing separators are allowed. The names within an object SHOULD be unique.</t>

<figure><artwork type="abnf"><![CDATA[
   object = begin-object
            ws-c
            [ member *( value-separator member ) [value-separator] ]
            ws-c
            end-object

   member = name ws-c name-separator ws-c value
]]></artwork></figure>

<t>If the Hjson text defines an object it does not have to include the braces at the root level:</t>

<figure><artwork type="abnf"><![CDATA[
   root-object =
            member
            *( value-separator member ) [value-separator]
]]></artwork></figure>

<t>A name can be specified as a JSON string (with quotes) or as a name without quotes.</t>

<figure><artwork type="abnf"><![CDATA[
   name = json-string / keyname

   keyname =  1*non-punctuator-char

   non-punctuator-char = %x21-2B / %x2D-39 / %x3B-5A /
                         %x5C / %x5E-7A / %x7C / %x7E-10FFFF
   ; any non-punctuator character (excludes ,:[]{} and ws)
]]></artwork></figure>

<t>For interoperability issues regarding the uniquness of names and object member ordering, see <xref target="RFC7159"/> Section 4.</t>

</section>
<section anchor="arrays" title="Arrays">

<t>An array structure is represented as square brackets surrounding zero or more values (or elements). Elements are separated by commas or linefeeds. Trailing commas are allowed.</t>

<figure><artwork type="abnf"><![CDATA[
   array =  begin-array
            ws-c
            [ value *( value-separator value ) [value-separator ] ]
            ws-c
            end-array
]]></artwork></figure>

<t>There is no requirement that the values in an array be of the same type.</t>

</section>
<section anchor="numbers" title="Numbers">

<t>The representation of numbers is similar to that used in most
programming languages. A number is represented in base 10 using
decimal digits. It contains an integer component that may be
prefixed with an optional minus sign, which may be followed by a
fraction part and/or an exponent part. Leading zeros are not
allowed.</t>

<t>A fraction part is a decimal point followed by one or more digits.</t>

<t>An exponent part begins with the letter E in upper or lower case,
which may be followed by a plus or minus sign. The E and optional
sign are followed by one or more digits.</t>

<t>Numeric values that cannot be represented in the grammar below (such
as Infinity and NaN) are not permitted.</t>

<figure><artwork type="abnf"><![CDATA[
   number = [ minus ] int [ frac ] [ exp ] !num-end

   decimal-point = %x2E       ; .

   digit = %x30-39            ; 0-9

   digit1-9 = %x31-39         ; 1-9

   e = %x65 / %x45            ; e E

   exp = e [ minus / plus ] 1*digit

   frac = decimal-point 1*digit

   int = zero / ( digit1-9 *digit )

   minus = %x2D               ; -

   plus = %x2B                ; +

   zero = %x30                ; 0

   num-end =  *( space / tab )
              ( %x21-22 / %x24-2B / %x2D-2E / %x30-5A /
              %x5C / %x5E-7A / %x7C / %x7E-10FFFF )
              ; exclude #/,[]{}

   ; SABNF: define num-end to prevent matches
   ;        that are actually a ql-string
   ;        (like "1 minute")
]]></artwork></figure>

<t>For limits on the range and precision of numbers see <xref target="RFC7159"/> Section 6.</t>

</section>
<section anchor="strings" title="Strings">

<t>Hjson allows strings to be represented in three different formats.</t>

<figure><artwork type="abnf"><![CDATA[
   string = json-string / ml-string / ql-string
]]></artwork></figure>

<section anchor="json-strings" title="JSON Strings">

<t>The representation of JSON strings is similar to conventions used in the C
family of programming languages. A string begins and ends with
quotation marks. All Unicode characters may be placed within the
quotation marks, except for the characters that must be escaped:
quotation mark, reverse solidus, and the control characters (U+0000
through U+001F).</t>

<t>Any character may be escaped. If the character is in the Basic
Multilingual Plane (U+0000 through U+FFFF), then it may be
represented as a six-character sequence: a reverse solidus, followed
by the lowercase letter u, followed by four hexadecimal digits that
encode the character’s code point. The hexadecimal letters A though
F can be upper or lower case. So, for example, a string containing
only a single reverse solidus character may be represented as
“\u005C”.</t>

<t>Alternatively, there are two-character sequence escape
representations of some popular characters. So, for example, a
string containing only a single reverse solidus character may be
represented more compactly as “\”.</t>

<t>To escape an extended character that is not in the Basic Multilingual
Plane, the character is represented as a 12-character sequence,
encoding the UTF-16 surrogate pair. So, for example, a string
containing only the G clef character (U+1D11E) may be represented as
“\uD834\uDD1E”.</t>

<figure><artwork type="abnf"><![CDATA[
   json-string = quotation-mark *char quotation-mark

   char = unescaped /
       escape (
           %x22 /          ; "    quotation mark  U+0022
           %x5C /          ; \    reverse solidus U+005C
           %x2F /          ; /    solidus         U+002F
           %x62 /          ; b    backspace       U+0008
           %x66 /          ; f    form feed       U+000C
           %x6E /          ; n    line feed       U+000A
           %x72 /          ; r    carriage return U+000D
           %x74 /          ; t    tab             U+0009
           %x75 4hexdig )  ; uXXXX                U+XXXX

   hexdig = %x30-39 / "A" / "B" / "C" / "D" / "E" / "F"

   escape = %x5C              ; \

   quotation-mark = %x22      ; "

   unescaped = %x20-21 / %x23-5B / %x5D-10FFFF
]]></artwork></figure>

</section>
<section anchor="quoteless-strings" title="Quoteless Strings">

<t>Hjson allows strings to be represented only by their content without quotes. A quoteless string may contain any character except the control characters (U+0000 through U+001F), excluding trailing whitespace. It cannot start with a punctuator character (,:[]{}). It ends at the first linefeed. Strings are taken as is without escapes.</t>

<figure><artwork type="abnf"><![CDATA[
   ql-string = non-punctuator-char
               *( !ql-end ql-char )

   ql-end    = *( space / tab / cr ) lf

   ql-char   = space / tab / %x21-10FFFF

   ; SABNF: define ql-end to exclude trailing
   ;        whitespace from the ql-string
]]></artwork></figure>

<t>A Hjson parser must still detect values (<spanx style="emph">number</spanx>, <spanx style="verb">true</spanx>, <spanx style="verb">false</spanx> or <spanx style="verb">null</spanx>) and parse them correctly. For example</t>

<t><list style="symbols">
  <t>‘3’ is the number 3</t>
  <t>‘5 times’ is the string “5 times”</t>
  <t>‘true’ is the boolean true</t>
  <t>‘7 # minutes’ is the number 7 followed by a comment</t>
  <t>’\s#([0-9a-fA-F]{3})’ is the string “\\s#([0-9a-fA-F]{3})”</t>
</list></t>

<t>Not allowing escapes inside the quoteless string allows you to specify HTML fragments, regular expressions or Windows style paths as-is, keeping them readable.</t>

</section>
<section anchor="multiline-strings" title="Multiline Strings">

<t>A multiline string begins and ends with three single quotes.</t>

<figure><artwork type="abnf"><![CDATA[
   ml-string =
      ml-seq
      *( !ml-seq ( ml-char / ml-ignore ) )
      ml-seq

   ml-seq = "'''"

   ml-char = space / tab / lf / %x21-10FFFF

   ml-ignore = cr

   ; SABNF: ml-string requies the use of the
   ;        ! operator to allow ' in the text
   ;        while stopping at '''
]]></artwork></figure>

<t>The carrige return character is generally ignored to make the parser platform independent.</t>

<t>Whitespace handling cannot be expressed in the ABNF grammar and is thus defined as:</t>

<t><list style="symbols">
  <t>Whitespace on the first line is ignored.</t>
  <t>The first three single quotes define the head. On the following lines all whitespace up to the column of the first single quote is ignored.</t>
  <t>All other whitespace is assumed to be part of the string.</t>
  <t>The last newline is ignored to allow for better formatting.</t>
</list></t>

</section>
</section>
<section anchor="string-and-character-issues" title="String and Character Issues">

<section anchor="character-encoding" title="Character Encoding">

<t>Hjson text SHALL be encoded in UTF-8. Since Hjson parsers can read JSON they may be able to read texts in other encodings (such as UTF-16 and UTF-32). Hjson texts that are encoded in UTF-8 are interoperable in the sense that they will be read successfully by the maximum number of implementations.</t>

<t>Implementations MUST NOT add a byte order mark to the beginning of a Hjson text. In the interests of interoperability, implementations that parse Hjson texts MAY ignore the presence of a byte order mark rather than treating it as an error.</t>

</section>
<section anchor="unicode-characters" title="Unicode Characters">

<t>See <xref target="RFC7159"/> Section 8.2.</t>

</section>
<section anchor="string-comparison" title="String Comparison">

<t>See <xref target="RFC7159"/> Section 8.3.</t>

</section>
</section>
<section anchor="parsers" title="Parsers">

<t>A Hjson parser transforms a Hjson text into another representation. A
Hjson parser MUST accept all texts that conform to the Hjson grammar.
A Hjson parser MAY accept non-Hjson forms or extensions.</t>

<t>An implementation may set limits on the size of texts that it
accepts. An implementation may set limits on the maximum depth of
nesting. An implementation may set limits on the range and precision
of numbers. An implementation may set limits on the length and
character contents of strings.</t>

</section>
<section anchor="generators" title="Generators">

<t>A Hjson generator produces Hjson text. The resulting text MUST
strictly conform to the Hjson grammar.</t>

</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>The MIME media type for Hjson text is application/hjson.</t>

<t>Type name:  application</t>

<t>Subtype name:  hjson</t>

<t>Required parameters:  n/a</t>

<t>Optional parameters:  n/a</t>

<t>Encoding considerations:  binary</t>

<t>Security considerations:  See &rfc.number;, <xref target="sec"/>.</t>

<t>Interoperability considerations:  Described in &rfc.number;</t>

<t>Published specification:  &rfc.number;</t>

<t>Applications that use this media type:
   Hjson has been used to provide configuration data for applications written in all of these programming languages: C#, Go, Java, JavaScript, PHP and Python</t>

<t>Additional information:
   Magic number(s): n/a
   File extension(s): .hjson
   Macintosh file type code(s): TEXT</t>

<t>Person &amp; email address to contact for further information:
   IESG
   <eref target="mailto:iesg@ietf.org">iesg@ietf.org</eref></t>

<t>Intended usage:  COMMON</t>

<t>Restrictions on usage:  none</t>

<t>Author:
   Christian Zangl
   <eref target="mailto:laktak@cdak.net">laktak@cdak.net</eref></t>

<t>Change controller:
   IESG
   <eref target="mailto:iesg@ietf.org">iesg@ietf.org</eref></t>

<t>Note:  No “charset” parameter is defined for this registration.
   Adding one really has no effect on compliant recipients.</t>

</section>
<section anchor="sec" title="Security Considerations">

<t>Unlike JSON, Hjson is not a subset of Javascript and cannot be parsed using “eval()”.</t>

</section>
<section anchor="examples" title="Examples">

<t>This is a Hjson object:</t>

<figure><artwork><![CDATA[
   # comments are useful

   # specify rate in requests/second
   rate: 1000

   #  you may also use
   // c style
   /* or block
      comments */

   # key names do not need to be placed in
   # quotes unless they contain a punctuator
   # character {}[],:
   key: 1

   # strings may also omit quotes if they do
   # not start with a punctuator
   text: look ma, no quotes!

   # quoteless strings do not use escapes
   # and end at the LF/newline

   # commas are optional
   commas:
   {
     one: 1
     two: 2
   }

   # trailing commas are allowed
   trailing:
   {
     one: 1,
     two: 2,
   }

   # multiline string
   haiku:
     '''
     JSON I love you.
     But you strangle my expression.
     This is so much better.
     '''

   # Hjson is a superset of JSON so you
   # may use any valid JSON syntax:
   favNumbers: [ 1, 2, 3, 6, 42 ]
]]></artwork></figure>

<section anchor="json-vs-hjson" title="JSON vs Hjson">

<t>Example of a document processor configuration, first in JSON:</t>

<figure><artwork><![CDATA[
   {
     "header": "The Foo Manual\nCopyright Bar Inc.",
     "source": {
       "include": [
         "./src"
       ],
       "includePattern": ".+\\.foo(doc)?$",
       "excludePattern": "(^|\\/|\\\\)_"
     },
     "templates": {
       "cleverLinks": false,
       "monospaceLinks": false
     }
   }
]]></artwork></figure>

<t>and in Hjson:</t>

<figure><artwork><![CDATA[
   # define the header using a multiline string
   header:
     '''
     The Foo Manual
     Copyright Bar Inc.
     '''
   source:
   {
     # generate documentation for these paths
     include:
     [
       ./src
     ]
     # include/exclude files
     # notice that no escapes are required
     includePattern: .+\.foo(doc)?$
     excludePattern: (^|\/|\\)_
   }
   templates: {
     # trailing commas are allowed
     cleverLinks: false,
     monospaceLinks: false,
   }
]]></artwork></figure>

<t>Example of a npm dependency configuration in JSON:</t>

<figure><artwork><![CDATA[
   {
     "dependencies": {
       "foo": "2.0.1",
       "bar": "*",
       "til": "~1.2.1",
       "elf": "^1.2.3"
     }
   }
]]></artwork></figure>

<t>and in Hjson:</t>

<figure><artwork><![CDATA[
   {
     dependencies:
     {
       // match version exactly
       foo: 2.0.1
       // * matches any version
       bar: *
       // approximately, allows patch-level changes
       til: ~1.2.1
       // compatible with major version
       elf: ^1.2.3
     }
   }
]]></artwork></figure>

</section>
</section>
<section anchor="contributors" title="Contributors">

<t>This document is based on <xref target="RFC4627"/> and <xref target="RFC7159"/> which were written by Douglas Crockford and Tim Bray. This document was constructed by extending it with the elements of the Hjson syntax.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>

&RFC4627;
&RFC7159;
&RFC2119;
&RFC5234;
<reference anchor="UNICODE" target="http://www.unicode.org/versions/latest/">
  <front>
    <title>The Unicode Standard</title>
    <author >
      <organization>The Unicode Consortium</organization>
    </author>
    <date year="n.d."/>
  </front>
</reference>
<reference anchor="SABNF" target="https://github.com/ldthomas/apg-js2/blob/2fa136e00e5932d70ed1bd4786101c87afa8ca2e/SABNF.md">
  <front>
    <title>Superset Augmented Backus-Naur Form</title>
    <author initials="L.D." surname="Thomas" fullname="Lowell D. Thomas">
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
  <seriesInfo name="version" value="2.2.1"/>
</reference>


    </references>




  </back>
</rfc>

